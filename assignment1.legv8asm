// Group: Shranav Sakha shranav8, Ashwin Shrestha ash78

main:
    ADD X0, XZR, XZR 
    ADDI X1, XZR, #100

    SUBI SP, SP, #24
    STUR LR, [Sp, #0]
	STUR X0, [SP, #8]
	STUR X1, [SP, #16]

	BL fill

    BL heapsort

    LDUR X1, [SP, #16]
    LDUR X0, [SP, #8]
    LDUR LR, [SP, #0]

    ADDI SP, SP, #24

    B end_program
    

    











//X0 = *a , X1 = s
fill:

    SUBI X28, X28, #16  // allocate space for registers
    STUR X19, [SP, #0] // saving register X19
    STUR X20, [SP, #8] // saving register X20


    ADD X9, XZR, XZR // i = 0

    
    LSR X11, X1, #1 // X11 = s/2
    ADDI X12, X1, #1 // X12 = s + 1
    LSR X13, X12, #1 // X13 = (s+1)/2


    SUBIS X10, X1, #2 // tmp = s - 2
    B.MI skip // if s < 2 skip 



    f_loop:
        SUBI X10, X9, X11 // tmp = i - s/2
        CBZ X10, skip // if (i == s/2) break

        
        ADDI X14, X9, #1 // X14 = i + 1
        LSL X15, X9, #1// X15 = i * 2
        ADDI X16, X15, #1 // X16 = i * 2 + 1

        //((s + 1) / 2) - (i + 1)
        SUB X19, X13, X14
        LSL X10, X19, #3 // tmp = X19 * 8

        ADD X10, X0, X10 // tmp = & a[X10]
        LDUR X20, [X10, #0] // val = a[X10]
        ADD X20, X15, XZR // val= i * 2
        STUR X20, [X10, #0] // a[((s + 1) / 2) - (i + 1)] = val;

        // ((s + 1) / 2) + i
        ADD X19, X13, X9
        LSL X10, X19, #3 // tmp = X19 * 8

        ADD X10, X0, X10 // tmp = & a[X10]
        LDUR X20, [X10, #0] // val =  a[X10]
        ADD X20, X16, XZR // val = i * 2
        STUR X20, [X10, #0] // a[((s + 1) / 2) + i] = val;

        
        ADDI X9, X9, #1 // i++
        B f_loop // unconditionally branch to loop

    
    skip:

        ANDIS X10, X1, #1 // if (s && 1)
        B.EQ end // skip to end

        ADD X19, XZR, XZR // X19 = 0
        LSL X10, X19, #3 // tmp = X19 * 8

        ADD X10, X0, X10 // tmp = & a[0]
        LDUR X20, [X10, #0] // val = a[0]
        SUBI X20, X1, #1 // val = s - 1
        STUR X20, [X10, #0] // a[0] = val
end:


    LDUR X20, [SP, #8] // Restore registers
    LDUR X19, [SP, #0] 
    ADDI SP, SP, #16 // Restore stack
    BR LR




//swap Procedure
// X0 = *a 
// X1 = *b
swap:
    LDUR X11, [X0, #0] // Load value of *a in X11
    LDUR X12, [X1, #0]  // Load value of *b in X12
    STUR X12 [X0, #0] // Store Value of X12 in *a
    STUR X11 [X1, #0]  // Store value of X11 in *b



// X0 = address of array a, X1 = s number of elements in a
heapify:
    SUBI SP, SP, #8 // Allocate Space on stack
    STUR LR, [SP, #0] // Save Link Register
    

    ADD X9, XZR, XZR // i = 0

    // Need : (s+1)/2
    ADDI X10, X1, #1 // X10 = s + 1
    LSR X10, X10, #1 // X10 = X10 / 2

    ADD X9, X9, X10 // i = (s+1)/2
    h_loop:
        SUBS X10, X9, XZR // Check if (s+1)/2 - i, where i is its initial value = 0
        CBZ X10, h_loop_end // if ((s+1)/2 - i == 0) break 

        ADD X3, XZR, X9 // Put i as the third parameter to be passed to percolate_down
        BL percolate_down

        SUBI X9, X9, #1 // i--

        B h_loop // unconditionally branch to h_loop
    
    h_loop_end:

    ADD X3, XZR, XZR // set the third parameter register 0
    BL percolate_down

    LDUR LR, [SP, #0] // Restore Link Register
    ADDI SP, SP, #8 // Restore Stack Pointer

    BR LR
        


// X0 = address of array a, X1 = s number of elements in a
heapsort:
    SUBI SP, SP, #8 // Allocate Space on stack
    STUR LR, [SP, #0] // Save Link Register
    
    ADD X14, X0, XZR // Saving X0 and X1
    ADD X15, X1, XZR 

    

    ADDI, X9, XZR, #1 // i = 1
    BL heapify

    //need: s - i, a[0] , a[s - i]

    s_loop:
        SUBS X10, X15, X9 // X10 = s - i
        CBZ X10, s_loop_end

        ADD X11, X14, XZR // X11 = & a[0]
        

        LSL X12, X10, #3 // tmp = (s - i) * 8
        ADD X12, X14, X12 // X12 = & a[s-i]
        
        ADD X0, X11, XZR // Move registers to be passed as parameters
        ADD X1, X12, XZR

        BL swap

        ADD X0, X14, XZR // Restore X0
        ADD X1, X10, XZR // X1 = s - i
        ADD X2, XZR, XZR // X2 = 0

        Bl percolate_down

        ADDI X9, X9, #1 // i++
    
    s_loop_end:

    LDUR LR, [SP, #0] // Restore Link register
    ADDI SP, SP, #8 // Restore Stack Pointer
    BR LR // return to caller

        
        
       


//X19 = a, X20 = s, X21 = i, X9 = child
percolate_down:
    SUBI SP, SP, #48 // Allocating space for registers
    STUR LR, [SP, #0] // Saving registers
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]
    STUR X21, [SP, #24]
    STUR X22, [SP, #32]
    STUR X23, [SP, #40]


    ADD X19, X0, XZR // saving X0
    ADD X20, X1, XZR // saving X1
    ADD X21, X2, XZR // saving X2


   ADD X9, XZR, XZR // child = 0 
loop:
   LSL X9, X21, #1  // X9 = 2 * i
   ADDI X9, X9, #1  // X9 = (2 * i) + 1
   SUBS X10, X9, X20  // child - s, checking if child < s
   B.GE end_loop // if child >= s, end the loop as (child < s is false)

   ADDI X11, X9, #1  // X11 = child + 1
   SUBS X12, X11, X20   // checking if child + 1 < s
   B.GE check_for_swap  // branch to next condition if child + 1 >= s

    LSL X22, X9, #3 // tmp = child * 8
    ADD X22, X19, X22 // tmp = & a[child]

    LSL X23, X11, #3 // tmp2 = (child + 1) * 8
    ADD X23, X19, X23 // tmp = & a[child+1]

   LDUR X13, [X22, #0] // a[child]
   LDUR X14, [X23, #0] // a[child + 1]
   SUBS X15, X13, X14  // a[child] - a[child + 1]
   B.GE check_for_swap  //branch to next condition if a[child] >= a[child + 1]

   ADDI X9, X9, #1 // child ++  (could also use X5)

check_for_swap:
    LSL X22, X21, #3 // tmp = i * 8 
    ADD X22, X19, X22 // tmp = & a[i]

    LSL X23, X9, #3 // tmp2 = child * 8
    ADD X23, X19, X23 // tmp2 = & a[child]


   LDUR X13, [X22, #0]  // a[i]
   LDUR X14, [X23, #0]  // a[child]
   SUBS X15, X13, X14 // a[i] - a[child]
   
   ADD X0, X19, X21 // a + i
   ADD X1, X19, X9 // a + child 

   B.GE loop // if a[i] >= a[child]

   B swap  // swap with X0 and X1

   ADD X21, X9, XZR  // i = child

   B loop  // return back to repeat again

end_loop:

    LDUR X23, [SP, #40] // restoring registers
    LDUR X22, [SP, #32]
    LDUR X21, [SP, #24]
    LDUR X20, [SP, #16]
    LDUR X19, [SP, #8]
    LDUR LR, [SP, #0]
    ADDI SP, SP, #48 // Restoring Stack Pointer

   BR LR

end_program:
    DUMP
    HALT



    
