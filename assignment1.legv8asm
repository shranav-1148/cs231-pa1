// Name: Shranav Sakha, Ashwin Shrestha
// netID: shranav8, ash78


//X0 = *a , X1 = s
fill:

    SUBI X28, X28, #16  // allocate space for registers
    STUR X19, [SP, #0] // saving register X19
    STUR X20, [SP, #8] // saving register X20


    ADD X9, XZR, XZR // i = 0

    
    LSR X11, X1, #1 // X11 = s/2
    ADDI X12, X1, #1 // X12 = s + 1
    LSR X13, X12, #1 // X13 = (s+1)/2


    SUBIS X10, X1, #2 // tmp = s - 2
    B.MI skip // if s < 2 skip 



    f_loop:
        SUBI X10, X9, X11 // tmp = i - s/2
        CBZ X10, skip // if (i == s/2) break

        
        ADDI X14, X9, #1 // X14 = i + 1
        LSL X15, X9, #1// X15 = i * 2
        ADDI X16, X15, #1 // X16 = i * 2 + 1

        //((s + 1) / 2) - (i + 1)
        SUB X19, X13, X14
        LSL X10, X19, #3 // tmp = X19 * 8

        ADD X10, X0, X10 // tmp = & a[X10]
        LDUR X20, [X10, #0] // val = a[X10]
        ADD X20, X15, XZR // val= i * 2
        STUR X20, [X10, #0] // a[((s + 1) / 2) - (i + 1)] = val;

        // ((s + 1) / 2) + i
        ADD X19, X13, X9
        LSL X10, X19, #3 // tmp = X19 * 8

        ADD X10, X0, X10 // tmp = & a[X10]
        LDUR X20, [X10, #0] // val =  a[X10]
        ADD X20, X16, XZR // val = i * 2
        STUR X20, [X10, #0] // a[((s + 1) / 2) + i] = val;

        
        ADDI X9, X9, #1 // i++
        B f_loop // unconditionally branch to loop

    
    skip:

        ANDIS X10, X1, #1 // if (s && 1)
        B.EQ end // skip to end

        ADD X19, XZR, XZR // X19 = 0
        LSL X10, X19, #3 // tmp = X19 * 8

        ADD X10, X0, X10 // tmp = & a[0]
        LDUR X20, [X10, #0] // val = a[0]
        SUBI X20, X1, #1 // val = s - 1
        STUR X20, [X10, #0] // a[0] = val
end:


    LDUR X20, [SP, #8] // Restore registers
    LDUR X19, [SP, #0] 
    ADDI SP, SP, #16 // Restore stack
    BR LR




//swap Procedure
// X0 = *a 
// X1 = *b
swap:
    LDUR X11, [X0, #0] // Load value of *a in X11
    LDUR X12, [X1, #0]  // Load value of *b in X12
    STUR X12 [X0, #0] // Store Value of X12 in *a
    STUR X11 [X1, #0]  // Store value of X11 in *b



// X0 = address of array a, X1 = s number of elements in a
heapify:
    SUBI SP, SP, #8 // Allocate Space on stack
    STUR LR, [SP, #0] // Save Link Register

    ADD X9, XZR, XZR // i = 0

    // Need : (s+1)/2
    ADDI X10, X1, #1 // X10 = s + 1
    LSR X10, X10, #1 // X10 = X10 / 2

    ADD X9, X9, X10 // i = (s+1)/2
    h_loop:
        SUBS X10, X9, XZR // Check if (s+1)/2 - i, where i is its initial value = 0
        CBZ X10, h_loop_end // if ((s+1)/2 - i == 0) break 

        ADD X3, XZR, X9 // Put i as the third parameter to be passed to percolate_down
        BL percolate_down

        SUBI X9, X9, #1 // i--

        B h_loop // unconditionally branch to h_loop
    
    h_loop_end:

    ADD X3, XZR, XZR // set the third parameter register 0
    BL percolate_down

    LDUR LR, [SP, #0] // Restore Link Register
    ADDI SP, SP, #8 // Restore Stack Pointer

    BR LR
        

heapsort:

    
